# Goe

## chat app description

A chat application that offers a extra layer of choice for users when reading their own messages. On login the user will have the choice of opening their message/s OR filtering the message/s to check for words that may offend them. If the user decides to filter they can then read their messages but with offensive words replaced with other words.

The first milestone ( first presentation) is to have the read/write messages page rendered and working. The user will have the choice to open messages without the filter OR use the filter to check message/s.

* Create account and login
* Write messages and send to recipient
* Save messages to json file or at a further STRETCH a database
* STRETCH: Create a chat group private and/or public
* STRETCH: Create a pictures private and/or public (top ten only and borrowable)

### Pre code set up

* README documentation
* Wireframe design for user interface (thinking about mobile first/responsive design)
* System design diagram.
* Data flow diagram.
* Database - table design eg fields, data types etc:
* Test document diagrams.

### Learning objectives

* File system set-up
* Terminal commands
* Keyboard shortcuts
* Git work flow
* Utilizing npm modules
* Server -side - api/routes
* Think about what user focused really means...
* More efficient js code eg: using ternary operators.
* Minimizing js file size for faster load time.
* Use regular expressions and validation tools
* Use actual/real data. (maybe sensitive)
* Write some code! (follow commenting conventions and syntax standards)

### Glossary of npm modules, js concepts and technologies....(Not sure what npm's I am using and this glossary can be removed from README).

* An npm chat app. There is a lot out there and yet to make a decision on this.
* Eslint standard eslint-airbub-config - a tool for identifying and reporting on patterns found in
ECMAScript/js code. Lets you know that you have semantic/syntax errors - that I know for sure. Can set rules for the programmer (standards to follow) in the config.
* Express and Express generator - node.js web application. Has tools for http servers. Write routes that [GET]/v1/message/s and [POST]/v1/message

* Cheerio - implementation of jQuery designed for the server
* fs - file system read and write
* Hyperscript - rendering html to the web page
* JSON - data interchange format. Collection of name/value pairs or an ordered list of values like an array.
* Knex npm for Sqlite3 database.
* Skeleton and normalize frameworks focusing on mobile first css design.
* SuperAgent - AJAX clientside http request library and node.js module. Works with browserify and webpack. My first attempt will be to render the many pages that html alone would render with one html page with AJAX an request.
* Supertest - superagent driven library for testing HTTP servers
* Tape - test harness for node and browsers.
* Tap--spec - formatted TAP output (colors output)
* Promises - represents the eventual result of asynchronous operations
* Slush-pages - a slush generator for static pages using browserify & jQuery.
* STRETCH: REST APIs twitter.com: access to read and write Twitter data. Will want read functionality to check/filter user's tweet messages.

:scream:#
